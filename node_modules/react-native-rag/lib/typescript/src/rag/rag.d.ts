import type { GetResult, Message, QueryResult } from '../types/common';
import type { LLM } from '../interfaces/llm';
import type { TextSplitter } from '../interfaces/textSplitter';
import type { VectorStore } from '../interfaces/vectorStore';
/**
 * Orchestrates Retrieval Augmented Generation.
 * Coordinates a `VectorStore` and an `LLM` to ingest, retrieve, and generate.
 *
 * @example
 * const rag = await new RAG({ vectorStore, llm }).load();
 * const answer = await rag.generate({ input: 'What is RAG?' });
 */
export declare class RAG {
    private vectorStore;
    private llm;
    /**
     * Creates a new RAG instance.
     * @param params - Object containing the implementations.
     * @param params.vectorStore - Vector store used for retrieval.
     * @param params.llm - Large Language Model used for generation.
     */
    constructor({ vectorStore, llm }: {
        vectorStore: VectorStore;
        llm: LLM;
    });
    /**
     * Initializes the RAG system by loading the vector store and LLM.
     * @returns A promise that resolves to the same `RAG` instance.
     */
    load(): Promise<this>;
    /**
     * Unloads the RAG system, releasing resources used by the vector store and LLM.
     * @returns A promise that resolves when unloading is complete.
     */
    unload(): Promise<void>;
    /**
     * Splits a document into chunks and adds them to the vector store.
     * If no `textSplitter` is provided, a default
     * `RecursiveCharacterTextSplitter({ chunkSize: 500, chunkOverlap: 100 })` is used.
     *
     * @param params - Parameters for the operation.
     * @param params.document - The content of the document to split and add.
     * @param params.metadataGenerator - Function to generate metadata for each chunk. Must return an array which length is equal to the number of chunks.
     * @param params.textSplitter - Text splitter implementation.
     * @returns Promise that resolves to the IDs of the newly added chunks.
     */
    splitAddDocument(params: {
        document: string;
        metadataGenerator?: (chunks: string[]) => Record<string, any>[];
        textSplitter?: TextSplitter;
    }): Promise<string[]>;
    /**
     * Adds a document to the vector store.
     * @param params - Parameters for the operation.
     * @param params.id - ID for the document.
     * @param params.document - Raw text content for the document.
     * @param params.embedding - Embedding for the document.
     * @param params.metadata - Metadata for the document.
     * @returns Promise that resolves to the ID of the newly added document.
     */
    addDocument(params: {
        id?: string;
        document?: string;
        embedding?: number[];
        metadata?: Record<string, any>;
    }): Promise<string>;
    /**
     * Updates a document in the vector store by its ID.
     * @param params - Parameters for the update.
     * @param params.id - The ID of the document to update.
     * @param params.document - New content for the document.
     * @param params.embedding - New embedding for the document. If not provided, it will be generated based on the `document`.
     * @param params.metadata - New metadata for the document.
     * @returns Promise that resolves once the document is updated.
     */
    updateDocument(params: {
        id: string;
        embedding?: number[];
        document?: string;
        metadata?: Record<string, any>;
    }): Promise<void>;
    /**
     * Deletes documents from the vector store by the provided predicate.
     * @param params - Parameters for deletion.
     * @param params.predicate - Predicate to match documents for deletion.
     * @returns Promise that resolves once the documents are deleted.
     */
    deleteDocument(params: {
        predicate: (value: GetResult) => boolean;
    }): Promise<void>;
    private questionGenerator;
    private promptGenerator;
    /**
     * Generates a response based on the input messages and retrieved documents.
     * If `augmentedGeneration` is true, it retrieves relevant documents from the vector store
     * and includes them in the prompt for the LLM.
     * @param params - Generation parameters.
     * @param params.input - Input messages or a single string.
     * @param params.augmentedGeneration - Whether to augment with retrieved context (default: true).
     * @param params.nResults - Number of docs to retrieve (default: 3).
     * @param params.predicate - Filter applied to retrieved docs.
     * @param params.questionGenerator - Maps the message list to a search query (default: last message content).
     * @param params.promptGenerator - Builds the context-augmented prompt from messages and retrieved docs.
     * @param params.callback - Token callback for streaming.
     * @returns Promise that resolves to the generated text.
     */
    generate(params: {
        input: Message[] | string;
        augmentedGeneration?: boolean;
        nResults?: number;
        predicate?: (value: QueryResult) => boolean;
        questionGenerator?: (messages: Message[]) => string;
        promptGenerator?: (messages: Message[], retrievedDocs: QueryResult[]) => string;
        callback?: (token: string) => void;
    }): Promise<string>;
    /**
     * Interrupts the ongoing text generation process.
     * @returns Promise that resolves when the interruption is complete.
     */
    interrupt(): Promise<void>;
}
//# sourceMappingURL=rag.d.ts.map