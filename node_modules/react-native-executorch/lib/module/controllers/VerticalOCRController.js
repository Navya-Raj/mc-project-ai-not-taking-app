"use strict";

import { symbols } from '../constants/ocr/symbols';
import { ETError, getError } from '../Error';
import { ResourceFetcher } from '../utils/ResourceFetcher';
export class VerticalOCRController {
  isReady = false;
  isGenerating = false;
  error = null;
  constructor({
    isReadyCallback = _isReady => {},
    isGeneratingCallback = _isGenerating => {},
    errorCallback = _error => {}
  } = {}) {
    this.isReadyCallback = isReadyCallback;
    this.isGeneratingCallback = isGeneratingCallback;
    this.errorCallback = errorCallback;
  }
  load = async (detectorSources, recognizerSources, language, independentCharacters, onDownloadProgressCallback) => {
    try {
      if (Object.keys(detectorSources).length !== 2 || Object.keys(recognizerSources).length !== 2) return;
      if (!symbols[language]) {
        throw new Error(getError(ETError.LanguageNotSupported));
      }
      this.isReady = false;
      this.isReadyCallback(this.isReady);
      const paths = await ResourceFetcher.fetch(onDownloadProgressCallback, detectorSources.detectorLarge, detectorSources.detectorNarrow, independentCharacters ? recognizerSources.recognizerSmall : recognizerSources.recognizerLarge);
      if (paths === null || paths.length < 3) {
        throw new Error('Download interrupted');
      }
      this.ocrNativeModule = global.loadVerticalOCR(paths[0], paths[1], paths[2], symbols[language], independentCharacters);
      this.isReady = true;
      this.isReadyCallback(this.isReady);
    } catch (e) {
      if (this.errorCallback) {
        this.errorCallback(getError(e));
      } else {
        throw new Error(getError(e));
      }
    }
  };
  forward = async input => {
    if (!this.isReady) {
      throw new Error(getError(ETError.ModuleNotLoaded));
    }
    if (this.isGenerating) {
      throw new Error(getError(ETError.ModelGenerating));
    }
    try {
      this.isGenerating = true;
      this.isGeneratingCallback(this.isGenerating);
      return await this.ocrNativeModule.generate(input);
    } catch (e) {
      throw new Error(getError(e));
    } finally {
      this.isGenerating = false;
      this.isGeneratingCallback(this.isGenerating);
    }
  };
  delete() {
    if (this.isGenerating) {
      throw new Error(getError(ETError.ModelGenerating) + 'You cannot delete the model. You must wait until the generating is finished.');
    }
    this.ocrNativeModule.unload();
    this.isReadyCallback(false);
    this.isGeneratingCallback(false);
  }
}
//# sourceMappingURL=VerticalOCRController.js.map